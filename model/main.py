from __future__ import division
import numpy as np
import os

N_NODES = 10

def generate_states():
    """
    Generates the Markov Chain depicted in the report
    """
    states = [] # [No. Trasmitting:int, No. Waiting for Transmitting:int, no collision happened:bool]

    for i in range(0, N_NODES):
        if i == 0:
            # first line of MC transition states
            states.append([i, i, True])
        elif i == 1:
            # all states where one node is transmitting, either colliding or successfully
            for j in range(0, N_NODES):
                states.append([i, j, True])
            for j in range(0, N_NODES):
                states.append([i, j, False])
        else:
            # all states where two or more nodes are transmitting, and thus there is always a collision
            for j in range(0, N_NODES + 1 - i):
                states.append([i, j, False])
    return states

def find_state(state, states):
    '''
    Return the position in the matrix states of a state
    -1 if not
    '''
    if state in states:
        return states.index(state)
    else:
        return -1

def compute_idle_node_generates_and_sends(item, lambda_value):
    """
    Compute the trasition rate
    when a new packet is generated by an idle node
    """
    # No. of nodes minus idle nodes times the inter-arrival rate lambda
    return (N_NODES - (item[0] + item[1])) * lambda_value

def compute_end_of_transmission(item):
    """
    Compute the transition rate
    when a node ends the trasmission, so to awake all waiting nodes
    """
    # No. of transmitting nodes multplied by mu
    return item[0] * 1

def generate_matrix(states, lambda_value):
    """
    Generate the infinitesimal generator associated with the MC
    """
    matrix = np.zeros((len(states), len(states)))

    for index, item in enumerate(states):
        if item == [0, 0, True]:
            # we are in the very first state
            # we can only generate with success the first packet
            matrix[0][1] = compute_idle_node_generates_and_sends([0, 0], lambda_value)
        elif item[0] == 1:
            # one node is transmitting

            # START OF TRANSMISSION
            next_state = [item[0], item[1] + 1, item[2]] # next state reachable if we generate a new packet
            position = find_state(next_state, states)
            if position != -1:
                matrix[index][position] = compute_idle_node_generates_and_sends(item, lambda_value)

            # END OF TRANSMISSION
            if item[1] == 0 or item[1] == 1:
                # only 0 or 1 node is waiting
                state = [item[1], 0, True]
            else:
                # 2 or more nodes are willing to transmit, they are waiting
                state = [item[1], 0, False]
            position = find_state(state, states)
            if position != -1:
                matrix[index][position] = compute_end_of_transmission(item)
        else:
            # START OF TRANSMISSION
            next_state = [item[0], item[1] + 1, False]
            position = find_state(next_state, states)
            if position != -1:
                matrix[index][position] = compute_idle_node_generates_and_sends(item, lambda_value)

            # END OF TRANSMISSION
            prev_state = [item[0] - 1, item[1], False]
            position = find_state(prev_state, states)
            if position != -1:
                matrix[index][position] = compute_end_of_transmission(item)

    for x in range(0, len(matrix)):
        # fill the diagonal
        matrix[x][x] = -sum(matrix[x])
    return matrix

def append_results(lambda_value, steady_state):
    """
    Save the steady state distribution to a csv file
    """
    output = './model/data/output.csv'
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'a') as f:
        for index, p in enumerate(steady_state[1:]):
            if index <= N_NODES: # only in the first ten states there are no collisions
                val = 't'
            else:
                val = 'c'
            if p < 0:
                p = 0
            f.write('{},{},{}\n'.format(val, p, (lambda_value / 1000 * 100 / 0.8))) 

def init_file():
    output = './model/data/output.csv'
    f = open(output, 'w+')
    f.write('state,prob,load\n')
    f.close()

def replace_last_column_with_1(matrix):
    matrix[::,-1] = 1
    return matrix

if __name__ == "__main__":
    # generate the states of the Markov Chain
    states = generate_states()
    N = len(states)
    init_file()
    # compute steady state distribution for each possible value of lambda [0.001, 0.1]
    for lambda_value in range(0, 1000, 10): # range(95, 10000, 10):
        # compute lambda
        if lambda_value == 0:
            lambda_value = 1
        l = lambda_value / 1000 # 100000
        print('[ STEP ] {}'.format(l))
        # create the infinitesimal generator associated with the MC
        transition_matrix = generate_matrix(states, l)
        Q = np.ones((N, N + 1))
        Q[:,:-1] = transition_matrix

        b = [0] * N # a list of zeros
        b.append(1)
        # compute the steady state of the MC
        # use lstsq numpy function to solve ax=b, where a is Q transposed, b is a probability vector like [0,0,...,0,1], x is the returned solution
        # solving the equation ??? in the report
        # https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linalg.lstsq.html
        steady_state_matrix = np.linalg.lstsq(Q.transpose(), b)

        steady_state_matrix2 = np.dot(replace_last_column_with_1(np.zeros((N, N))), np.linalg.inv(replace_last_column_with_1(transition_matrix - np.identity(N))))
        #print(steady_state_matrix2)

        #print(np.dot(steady_state_matrix2, (transition_matrix - np.identity(N))))
        #print(np.dot(steady_state_matrix[0], transition_matrix))
        #print(np.isclose(a=np.dot(steady_state_matrix2, (transition_matrix - np.identity(N))), b=np.zeros((N, N))))
        #print('----')

        #print(steady_state_matrix)
        append_results(lambda_value, steady_state_matrix[0])
        
        